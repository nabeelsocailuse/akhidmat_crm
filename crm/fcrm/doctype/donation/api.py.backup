import frappe

@frappe.whitelist()
def get_donation(name):
    """Get donation details by name"""
    try:
        # Since donation doctype exists in akf_accounts, we'll fetch from there
        if frappe.db.exists("Donation", name):
            donation = frappe.get_doc("Donation", name)
            return donation.as_dict()
        else:
            frappe.throw(f"Donation {name} not found")
    except Exception as e:
        frappe.throw(f"Error fetching donation: {str(e)}")

@frappe.whitelist()
def get_deduction_details(fund_class, company=None):
    """Get deduction details for a fund class"""
    try:
        if not fund_class:
            return {}
        
        # Get ALL deduction details for this fund class (not just the first one)
        result = frappe.db.sql("""
            SELECT 
                company, income_type, project, account, 
                percentage, min_percent, max_percent
            FROM 
                `tabDeduction Details` dd
            WHERE 
                parent = %(fund_class)s
            ORDER BY idx
        """, {
            'fund_class': fund_class
        }, as_dict=True)
        
        # Return all results if available
        if result and len(result) > 0:
            return result
        else:
            return {}
            
    except Exception as e:
        # No logging at all - just return empty dict
        return {}

@frappe.whitelist()
def test_api():
    """Test endpoint to verify API is working"""
    return {"message": "API is working", "timestamp": frappe.utils.now()}

@frappe.whitelist()
def test_deduction_simple(fund_class):
    """Simple test endpoint for deduction details"""
    try:
        result = frappe.db.sql("""
            SELECT percentage, min_percent, max_percent
            FROM `tabDeduction Details`
            WHERE parent = %s
            LIMIT 1
        """, (fund_class,), as_dict=True)
        
        if result:
            return {"success": True, "data": result[0]}
        else:
            return {"success": False, "message": "No data found"}
            
    except Exception as e:
        return {"success": False, "error": str(e)[:100]} 


@frappe.whitelist()
def get_fund_class_details(fund_class_id, company=None):
    """
    Get fund class details including service area, subservice area, product, and account information.
    This method is called from the frontend when a fund class is selected in payment details.
    """
    try:
        if not fund_class_id:
            return {}
       
        # Get the fund class document
        fund_class = frappe.get_doc("Fund Class", fund_class_id)
       
        # Get basic fund class details
        result = {
            'service_area': fund_class.service_area,
            'subservice_area': fund_class.subservice_area,
            'product': fund_class.product,
            'fund_class_name': fund_class.fund_class_name
        }
       
        # Get account defaults if company is provided
        if company and fund_class.accounts_default:
            for account_default in fund_class.accounts_default:
                if account_default.company == company:
                    result.update({
                        'equity_account': account_default.equity_account,
                        'receivable_account': account_default.receivable_account,
                        'cost_center': account_default.cost_center
                    })
                    break
       
        # If no company-specific accounts found, try to get any available accounts
        if not company and fund_class.accounts_default:
            for account_default in fund_class.accounts_default:
                result.update({
                    'equity_account': account_default.equity_account,
                    'receivable_account': account_default.receivable_account,
                    'cost_center': account_default.cost_center
                })
                break
       
        return result
       
    except Exception as e:
        frappe.log_error(f"Error in get_fund_class_details: {str(e)}", "Fund Class Details Error")
        return {}
@frappe.whitelist()
def populate_deduction_breakeven(payment_details, company, contribution_type, donation_cost_center, currency=None, to_currency=None, posting_date=None, is_return=False):
    """
    Populate deduction breakeven table based on payment details.
    This replicates the backend set_deduction_breakeven functionality.
    
    Args:
        payment_details: List of payment detail rows
        company: Company name
        contribution_type: Contribution type (Donation/Pledge)
        donation_cost_center: Donation cost center
        currency: Base currency
        to_currency: Target currency
        posting_date: Posting date for currency conversion
        is_return: Whether this is a return transaction
    """
    try:
        if not payment_details or not isinstance(payment_details, list):
            return {"success": False, "message": "Invalid payment details"}
        
        if not company:
            return {"success": False, "message": "Company is required"}
        
        deduction_breakeven_rows = []
        total_deduction_amount = 0
        total_donation = 0
        
        for row in payment_details:
            # Validate required fields
            if not row.get('random_id'):
                row['random_id'] = frappe.generate_hash(length=8)
            
            if not row.get('donor_id'):
                continue
                
            if not row.get('fund_class_id'):
                continue
                
            if not row.get('donation_amount') or row.get('donation_amount', 0) <= 0:
                continue
            
            # Validate active donor
            if not validate_active_donor(row.get('donor_id')):
                continue
            
            # Validate donor currency if provided
            if currency and not validate_donor_currency(row.get('donor_id'), currency):
                continue
            
            # Verify unique receipt number
            if not verify_unique_receipt_no(row, payment_details):
                continue
            
            # Reset mode of payment for Pledge
            reset_mode_of_payment(row, contribution_type)
            
            total_donation += row.get('donation_amount', 0)
            temp_deduction_amount = 0
            
            # Get deduction details for this payment row
            deduction_details = get_deduction_details_for_row(row, company, contribution_type)
            
            for deduction_detail in deduction_details:
                percentage_amount = 0
                base_amount = 0
                
                if row.get('donation_amount', 0) > 0 or is_return:
                    percentage_amount = row.get('donation_amount', 0) * (deduction_detail.get('percentage', 0) / 100)
                    base_amount = apply_currency_exchange(percentage_amount, currency, to_currency, posting_date)
                    temp_deduction_amount += percentage_amount
                
                # Create deduction breakeven row
                deduction_row = create_deduction_breakeven_row(
                    row, deduction_detail, percentage_amount, base_amount, 
                    company, donation_cost_center
                )
                
                deduction_breakeven_rows.append(deduction_row)
            
            # Set account details for payment row
            row['equity_account'] = get_default_accounts(row.get('fund_class_id'), 'equity_account', company)
            default_receivable_account = get_default_donor_account(row.get('donor_id'), "default_account")
            row['receivable_account'] = default_receivable_account if default_receivable_account else get_default_accounts(row.get('pay_service_area'), 'receivable_account', company)
            row['cost_center'] = donation_cost_center
            
            # Calculate amounts
            row['deduction_amount'] = temp_deduction_amount
            row['net_amount'] = row.get('donation_amount', 0) - temp_deduction_amount
            row['outstanding_amount'] = row.get('donation_amount', 0) if contribution_type == "Pledge" else row['net_amount']
            
            # Currency conversion
            row['base_donation_amount'] = apply_currency_exchange(row.get('donation_amount', 0), currency, to_currency, posting_date)
            row['base_deduction_amount'] = apply_currency_exchange(temp_deduction_amount, currency, to_currency, posting_date)
            row['base_net_amount'] = apply_currency_exchange(row['net_amount'], currency, to_currency, posting_date)
            row['base_outstanding_amount'] = apply_currency_exchange(row['outstanding_amount'], currency, to_currency, posting_date)
            
            total_deduction_amount += temp_deduction_amount
        
        return {
            "success": True,
            "deduction_breakeven": deduction_breakeven_rows,
            "updated_payment_details": payment_details,
            "total_donation": total_donation,
            "total_deduction_amount": total_deduction_amount,
            "total_donors": len(payment_details)
        }
        
    except Exception as e:
        frappe.log_error(f"Error in populate_deduction_breakeven: {str(e)}", "Deduction Breakeven Error")
        return {"success": False, "message": f"Error populating deduction breakeven: {str(e)}"}

def get_deduction_details_for_row(row, company, contribution_type):
    """Get deduction details for a specific payment row"""
    try:
        # Skip deduction for Zakat or Pledge
        intention_id = row.get('intention_id')
        if intention_id in [None, "Zakat"] or contribution_type == 'Pledge':
            return []
        
        fund_class_id = row.get('fund_class_id')
        if not fund_class_id:
            return []
        
        result = frappe.db.sql("""
            SELECT 
                company, income_type, project, account, 
                percentage, min_percent, max_percent
            FROM 
                `tabDeduction Details` dd
            WHERE 
                ifnull(account, "") != ""
                and company = %(company)s
                and parenttype = "Fund Class"
                and parent = %(fund_class_id)s
        """, {
            'company': company,
            'fund_class_id': fund_class_id
        }, as_dict=True)
        
        return result
        
    except Exception as e:
        frappe.log_error(f"Error getting deduction details: {str(e)}", "Deduction Details Error")
        return []

def create_deduction_breakeven_row(payment_row, deduction_detail, percentage_amount, base_amount, company, donation_cost_center):
    """Create a deduction breakeven row"""
    return {
        "random_id": payment_row.get('random_id'),
        "company": company,
        "income_type": deduction_detail.get('income_type'),
        "project": deduction_detail.get('project'),
        "account": deduction_detail.get('account'),
        "percentage": deduction_detail.get('percentage', 0),
        "min_percent": deduction_detail.get('min_percent', 0),
        "max_percent": deduction_detail.get('max_percent', 0),
        "donation_amount": payment_row.get('donation_amount', 0),
        "amount": percentage_amount,
        "base_amount": base_amount,
        "project_id": deduction_detail.get('project'),
        "cost_center_id": donation_cost_center,
        "fund_class_id": payment_row.get('fund_class_id'),
        "service_area_id": payment_row.get('pay_service_area'),
        "subservice_area_id": payment_row.get('pay_subservice_area'),
        "product_id": payment_row.get('pay_product'),
        "donor_id": payment_row.get('donor_id'),
        "donor_type_id": payment_row.get('donor_type'),
        "donor_desk_id": payment_row.get('donor_desk_id'),
        "intention_id": payment_row.get('intention_id'),
        "transaction_type_id": payment_row.get('transaction_type_id'),
        "__islocal": True,
        "doctype": "Deduction Breakeven",
        "parentfield": "deduction_breakeven",
        "parenttype": "Donation"
    }

def validate_active_donor(donor_id):
    """Validate if donor is active"""
    try:
        if not donor_id:
            return False
        
        donor_status = frappe.db.get_value("Donor", {"name": donor_id}, "status")
        return donor_status != "Blocked"
        
    except Exception:
        return False

def validate_donor_currency(donor_id, currency):
    """Validate if donor currency matches the required currency"""
    try:
        if not donor_id or not currency:
            return True
        
        donor_currency = frappe.db.get_value("Donor", {"name": donor_id}, "default_currency")
        return donor_currency == currency
        
    except Exception:
        return True

def verify_unique_receipt_no(row, all_payment_details):
    """Verify that receipt number is unique across all payment details"""
    try:
        receipt_number = row.get('receipt_number')
        if not receipt_number:
            return True
        
        current_idx = row.get('idx', 0)
        for other_row in all_payment_details:
            if (other_row.get('receipt_number') == receipt_number and 
                other_row.get('idx', 0) != current_idx):
                return False
        
        return True
        
    except Exception:
        return True

def reset_mode_of_payment(row, contribution_type):
    """Reset mode of payment based on contribution type"""
    try:
        if contribution_type == "Pledge":
            row['mode_of_payment'] = None
            row['account_paid_to'] = None
            row['transaction_no_cheque_no'] = ""
            row['reference_date'] = None
    except Exception:
        pass

def get_default_accounts(parent_id, fieldname, company):
    """Get default accounts from Accounts Default"""
    try:
        if not parent_id or not fieldname or not company:
            return None
        
        return frappe.db.get_value('Accounts Default', {
            'parent': parent_id, 
            'company': company
        }, fieldname)
        
    except Exception:
        return None

def get_default_donor_account(donor_id, fieldname):
    """Get default account from Donor"""
    try:
        if not donor_id or not fieldname:
            return None
        
        return frappe.db.get_value('Donor', {'name': donor_id}, fieldname)
        
    except Exception:
        return None

def apply_currency_exchange(amount, from_currency, to_currency, posting_date):
    """Apply currency exchange rate"""
    try:
        if not amount or not from_currency or not to_currency:
            return amount
        
        if from_currency == to_currency:
            return amount
        
        from erpnext.setup.utils import get_exchange_rate
        exchange_rate = get_exchange_rate(from_currency, to_currency, posting_date)
        
        if exchange_rate:
            return amount * exchange_rate
        
        return amount
        
    except Exception:
        return amount

@frappe.whitelist()
def update_deduction_breakeven(payment_details, deduction_breakeven, company, contribution_type, donation_cost_center, currency=None, to_currency=None, posting_date=None, is_return=False):
    """
    Update deduction breakeven table for existing donation.
    This replicates the backend update_deduction_breakeven functionality.
    """
    try:
        if not payment_details or not isinstance(payment_details, list):
            return {"success": False, "message": "Invalid payment details"}
        
        if not company:
            return {"success": False, "message": "Company is required"}
        
        updated_deduction_breakeven = []
        total_deduction_amount = 0
        total_donation = 0
        
        for payment_row in payment_details:
            total_donation += payment_row.get('donation_amount', 0)
            payment_row['base_donation_amount'] = apply_currency_exchange(
                payment_row.get('donation_amount', 0), currency, to_currency, posting_date
            )
            
            temp_deduction_amount = 0
            
            # Find matching deduction breakeven rows
            matching_deductions = [
                d for d in deduction_breakeven 
                if d.get('random_id') == payment_row.get('random_id')
            ]
            
            for deduction_row in matching_deductions:
                percentage_amount = 0
                base_amount = 0
                
                if payment_row.get('donation_amount', 0) > 0 or is_return:
                    percentage_amount = payment_row.get('donation_amount', 0) * (deduction_row.get('percentage', 0) / 100)
                    base_amount = apply_currency_exchange(percentage_amount, currency, to_currency, posting_date)
                    temp_deduction_amount += percentage_amount
                
                # Update deduction row
                deduction_row['amount'] = percentage_amount
                deduction_row['base_amount'] = base_amount
                deduction_row['donation_amount'] = payment_row.get('donation_amount', 0)
                
                updated_deduction_breakeven.append(deduction_row)
            
            # Update payment row amounts
            payment_row['deduction_amount'] = temp_deduction_amount
            payment_row['net_amount'] = payment_row.get('donation_amount', 0) - temp_deduction_amount
            payment_row['outstanding_amount'] = payment_row.get('donation_amount', 0) if contribution_type == "Pledge" else payment_row['net_amount']
            
            # Currency conversion
            payment_row['base_deduction_amount'] = apply_currency_exchange(temp_deduction_amount, currency, to_currency, posting_date)
            payment_row['base_net_amount'] = apply_currency_exchange(payment_row['net_amount'], currency, to_currency, posting_date)
            payment_row['base_outstanding_amount'] = apply_currency_exchange(payment_row['outstanding_amount'], currency, to_currency, posting_date)
            
            total_deduction_amount += temp_deduction_amount
        
        return {
            "success": True,
            "deduction_breakeven": updated_deduction_breakeven,
            "updated_payment_details": payment_details,
            "total_donation": total_donation,
            "total_deduction_amount": total_deduction_amount
        }
        
    except Exception as e:
        frappe.log_error(f"Error in update_deduction_breakeven: {str(e)}", "Update Deduction Breakeven Error")
        return {"success": False, "message": f"Error updating deduction breakeven: {str(e)}"}

@frappe.whitelist()
def validate_deduction_percentages(deduction_breakeven):
    """
    Validate deduction percentages against min/max limits.
    This replicates the backend validate_deduction_percentages functionality.
    """
    try:
        if not deduction_breakeven or not isinstance(deduction_breakeven, list):
            return {"success": True, "message": "No deduction breakeven to validate"}
        
        errors = []
        
        for row in deduction_breakeven:
            if not row.get('account'):
                continue
            
            fund_class = row.get('fund_class_id')
            account = row.get('account')
            percentage = row.get('percentage', 0)
            
            # Get min/max percentage for this account
            min_max = get_min_max_percentage(fund_class, account)
            
            if min_max and min_max.get('min_percentage') is not None and min_max.get('max_percentage') is not None:
                min_percentage = min_max.get('min_percentage')
                max_percentage = min_max.get('max_percentage')
                
                if percentage < min_percentage or percentage > max_percentage:
                    errors.append(f"Row#{row.get('idx', 'N/A')}: Percentage for account '{account}' must be between {min_percentage}% and {max_percentage}%.")
        
        if errors:
            return {"success": False, "errors": errors}
        
        return {"success": True, "message": "All percentages are valid"}
        
    except Exception as e:
        frappe.log_error(f"Error in validate_deduction_percentages: {str(e)}", "Deduction Percentage Validation Error")
        return {"success": False, "message": f"Error validating percentages: {str(e)}"}

def get_min_max_percentage(fund_class, account):
    """Get min/max percentage for a fund class and account combination"""
    try:
        if not fund_class or not account:
            return None
        
        result = frappe.db.sql("""
            SELECT min_percent, max_percent
            FROM `tabDeduction Details`
            WHERE parent = %(fund_class)s AND account = %(account)s
            LIMIT 1
        """, {
            'fund_class': fund_class,
            'account': account
        }, as_dict=True)
        
        if result:
            return {
                'min_percentage': result[0].get('min_percent'),
                'max_percentage': result[0].get('max_percent')
            }
        
        return None
        
    except Exception:
        return None
@frappe.whitelist()
def populate_deduction_breakeven(payment_details, company, contribution_type, donation_cost_center, currency=None, to_currency=None, posting_date=None, is_return=False):
    """
    Populate deduction breakeven table based on payment details.
    This replicates the backend set_deduction_breakeven functionality.
    
    Args:
        payment_details: List of payment detail rows
        company: Company name
        contribution_type: Contribution type (Donation/Pledge)
        donation_cost_center: Donation cost center
        currency: Base currency
        to_currency: Target currency
        posting_date: Posting date for currency conversion
        is_return: Whether this is a return transaction
    """
    try:
        if not payment_details or not isinstance(payment_details, list):
            return {"success": False, "message": "Invalid payment details"}
        
        if not company:
            return {"success": False, "message": "Company is required"}
        
        deduction_breakeven_rows = []
        total_deduction_amount = 0
        total_donation = 0
        
        for row in payment_details:
            # Validate required fields
            if not row.get('random_id'):
                row['random_id'] = frappe.generate_hash(length=8)
            
            if not row.get('donor_id'):
                continue
                
            if not row.get('fund_class_id'):
                continue
                
            if not row.get('donation_amount') or row.get('donation_amount', 0) <= 0:
                continue
            
            # Validate active donor
            if not validate_active_donor(row.get('donor_id')):
                continue
            
            # Validate donor currency if provided
            if currency and not validate_donor_currency(row.get('donor_id'), currency):
                continue
            
            # Verify unique receipt number
            if not verify_unique_receipt_no(row, payment_details):
                continue
            
            # Reset mode of payment for Pledge
            reset_mode_of_payment(row, contribution_type)
            
            total_donation += row.get('donation_amount', 0)
            temp_deduction_amount = 0
            
            # Get deduction details for this payment row
            deduction_details = get_deduction_details_for_row(row, company, contribution_type)
            
            for deduction_detail in deduction_details:
                percentage_amount = 0
                base_amount = 0
                
                if row.get('donation_amount', 0) > 0 or is_return:
                    percentage_amount = row.get('donation_amount', 0) * (deduction_detail.get('percentage', 0) / 100)
                    base_amount = apply_currency_exchange(percentage_amount, currency, to_currency, posting_date)
                    temp_deduction_amount += percentage_amount
                
                # Create deduction breakeven row
                deduction_row = create_deduction_breakeven_row(
                    row, deduction_detail, percentage_amount, base_amount, 
                    company, donation_cost_center
                )
                
                deduction_breakeven_rows.append(deduction_row)
            
            # Set account details for payment row
            row['equity_account'] = get_default_accounts(row.get('fund_class_id'), 'equity_account', company)
            default_receivable_account = get_default_donor_account(row.get('donor_id'), "default_account")
            row['receivable_account'] = default_receivable_account if default_receivable_account else get_default_accounts(row.get('pay_service_area'), 'receivable_account', company)
            row['cost_center'] = donation_cost_center
            
            # Calculate amounts
            row['deduction_amount'] = temp_deduction_amount
            row['net_amount'] = row.get('donation_amount', 0) - temp_deduction_amount
            row['outstanding_amount'] = row.get('donation_amount', 0) if contribution_type == "Pledge" else row['net_amount']
            
            # Currency conversion
            row['base_donation_amount'] = apply_currency_exchange(row.get('donation_amount', 0), currency, to_currency, posting_date)
            row['base_deduction_amount'] = apply_currency_exchange(temp_deduction_amount, currency, to_currency, posting_date)
            row['base_net_amount'] = apply_currency_exchange(row['net_amount'], currency, to_currency, posting_date)
            row['base_outstanding_amount'] = apply_currency_exchange(row['outstanding_amount'], currency, to_currency, posting_date)
            
            total_deduction_amount += temp_deduction_amount
        
        return {
            "success": True,
            "deduction_breakeven": deduction_breakeven_rows,
            "updated_payment_details": payment_details,
            "total_donation": total_donation,
            "total_deduction_amount": total_deduction_amount,
            "total_donors": len(payment_details)
        }
        
    except Exception as e:
        frappe.log_error(f"Error in populate_deduction_breakeven: {str(e)}", "Deduction Breakeven Error")
        return {"success": False, "message": f"Error populating deduction breakeven: {str(e)}"}

def get_deduction_details_for_row(row, company, contribution_type):
    """Get deduction details for a specific payment row"""
    try:
        # Skip deduction for Zakat or Pledge
        intention_id = row.get('intention_id')
        if intention_id in [None, "Zakat"] or contribution_type == 'Pledge':
            return []
        
        fund_class_id = row.get('fund_class_id')
        if not fund_class_id:
            return []
        
        result = frappe.db.sql("""
            SELECT 
                company, income_type, project, account, 
                percentage, min_percent, max_percent
            FROM 
                `tabDeduction Details` dd
            WHERE 
                ifnull(account, "") != ""
                and company = %(company)s
                and parenttype = "Fund Class"
                and parent = %(fund_class_id)s
        """, {
            'company': company,
            'fund_class_id': fund_class_id
        }, as_dict=True)
        
        return result
        
    except Exception as e:
        frappe.log_error(f"Error getting deduction details: {str(e)}", "Deduction Details Error")
        return []

def create_deduction_breakeven_row(payment_row, deduction_detail, percentage_amount, base_amount, company, donation_cost_center):
    """Create a deduction breakeven row"""
    return {
        "random_id": payment_row.get('random_id'),
        "company": company,
        "income_type": deduction_detail.get('income_type'),
        "project": deduction_detail.get('project'),
        "account": deduction_detail.get('account'),
        "percentage": deduction_detail.get('percentage', 0),
        "min_percent": deduction_detail.get('min_percent', 0),
        "max_percent": deduction_detail.get('max_percent', 0),
        "donation_amount": payment_row.get('donation_amount', 0),
        "amount": percentage_amount,
        "base_amount": base_amount,
        "project_id": deduction_detail.get('project'),
        "cost_center_id": donation_cost_center,
        "fund_class_id": payment_row.get('fund_class_id'),
        "service_area_id": payment_row.get('pay_service_area'),
        "subservice_area_id": payment_row.get('pay_subservice_area'),
        "product_id": payment_row.get('pay_product'),
        "donor_id": payment_row.get('donor_id'),
        "donor_type_id": payment_row.get('donor_type'),
        "donor_desk_id": payment_row.get('donor_desk_id'),
        "intention_id": payment_row.get('intention_id'),
        "transaction_type_id": payment_row.get('transaction_type_id'),
        "__islocal": True,
        "doctype": "Deduction Breakeven",
        "parentfield": "deduction_breakeven",
        "parenttype": "Donation"
    }

def validate_active_donor(donor_id):
    """Validate if donor is active"""
    try:
        if not donor_id:
            return False
        
        donor_status = frappe.db.get_value("Donor", {"name": donor_id}, "status")
        return donor_status != "Blocked"
        
    except Exception:
        return False

def validate_donor_currency(donor_id, currency):
    """Validate if donor currency matches the required currency"""
    try:
        if not donor_id or not currency:
            return True
        
        donor_currency = frappe.db.get_value("Donor", {"name": donor_id}, "default_currency")
        return donor_currency == currency
        
    except Exception:
        return True

def verify_unique_receipt_no(row, all_payment_details):
    """Verify that receipt number is unique across all payment details"""
    try:
        receipt_number = row.get('receipt_number')
        if not receipt_number:
            return True
        
        current_idx = row.get('idx', 0)
        for other_row in all_payment_details:
            if (other_row.get('receipt_number') == receipt_number and 
                other_row.get('idx', 0) != current_idx):
                return False
        
        return True
        
    except Exception:
        return True

def reset_mode_of_payment(row, contribution_type):
    """Reset mode of payment based on contribution type"""
    try:
        if contribution_type == "Pledge":
            row['mode_of_payment'] = None
            row['account_paid_to'] = None
            row['transaction_no_cheque_no'] = ""
            row['reference_date'] = None
    except Exception:
        pass

def get_default_accounts(parent_id, fieldname, company):
    """Get default accounts from Accounts Default"""
    try:
        if not parent_id or not fieldname or not company:
            return None
        
        return frappe.db.get_value('Accounts Default', {
            'parent': parent_id, 
            'company': company
        }, fieldname)
        
    except Exception:
        return None

def get_default_donor_account(donor_id, fieldname):
    """Get default account from Donor"""
    try:
        if not donor_id or not fieldname:
            return None
        
        return frappe.db.get_value('Donor', {'name': donor_id}, fieldname)
        
    except Exception:
        return None

def apply_currency_exchange(amount, from_currency, to_currency, posting_date):
    """Apply currency exchange rate"""
    try:
        if not amount or not from_currency or not to_currency:
            return amount
        
        if from_currency == to_currency:
            return amount
        
        from erpnext.setup.utils import get_exchange_rate
        exchange_rate = get_exchange_rate(from_currency, to_currency, posting_date)
        
        if exchange_rate:
            return amount * exchange_rate
        
        return amount
        
    except Exception:
        return amount

@frappe.whitelist()
def update_deduction_breakeven(payment_details, deduction_breakeven, company, contribution_type, donation_cost_center, currency=None, to_currency=None, posting_date=None, is_return=False):
    """
    Update deduction breakeven table for existing donation.
    This replicates the backend update_deduction_breakeven functionality.
    """
    try:
        if not payment_details or not isinstance(payment_details, list):
            return {"success": False, "message": "Invalid payment details"}
        
        if not company:
            return {"success": False, "message": "Company is required"}
        
        updated_deduction_breakeven = []
        total_deduction_amount = 0
        total_donation = 0
        
        for payment_row in payment_details:
            total_donation += payment_row.get('donation_amount', 0)
            payment_row['base_donation_amount'] = apply_currency_exchange(
                payment_row.get('donation_amount', 0), currency, to_currency, posting_date
            )
            
            temp_deduction_amount = 0
            
            # Find matching deduction breakeven rows
            matching_deductions = [
                d for d in deduction_breakeven 
                if d.get('random_id') == payment_row.get('random_id')
            ]
            
            for deduction_row in matching_deductions:
                percentage_amount = 0
                base_amount = 0
                
                if payment_row.get('donation_amount', 0) > 0 or is_return:
                    percentage_amount = payment_row.get('donation_amount', 0) * (deduction_row.get('percentage', 0) / 100)
                    base_amount = apply_currency_exchange(percentage_amount, currency, to_currency, posting_date)
                    temp_deduction_amount += percentage_amount
                
                # Update deduction row
                deduction_row['amount'] = percentage_amount
                deduction_row['base_amount'] = base_amount
                deduction_row['donation_amount'] = payment_row.get('donation_amount', 0)
                
                updated_deduction_breakeven.append(deduction_row)
            
            # Update payment row amounts
            payment_row['deduction_amount'] = temp_deduction_amount
            payment_row['net_amount'] = payment_row.get('donation_amount', 0) - temp_deduction_amount
            payment_row['outstanding_amount'] = payment_row.get('donation_amount', 0) if contribution_type == "Pledge" else payment_row['net_amount']
            
            # Currency conversion
            payment_row['base_deduction_amount'] = apply_currency_exchange(temp_deduction_amount, currency, to_currency, posting_date)
            payment_row['base_net_amount'] = apply_currency_exchange(payment_row['net_amount'], currency, to_currency, posting_date)
            payment_row['base_outstanding_amount'] = apply_currency_exchange(payment_row['outstanding_amount'], currency, to_currency, posting_date)
            
            total_deduction_amount += temp_deduction_amount
        
        return {
            "success": True,
            "deduction_breakeven": updated_deduction_breakeven,
            "updated_payment_details": payment_details,
            "total_donation": total_donation,
            "total_deduction_amount": total_deduction_amount
        }
        
    except Exception as e:
        frappe.log_error(f"Error in update_deduction_breakeven: {str(e)}", "Update Deduction Breakeven Error")
        return {"success": False, "message": f"Error updating deduction breakeven: {str(e)}"}

@frappe.whitelist()
def validate_deduction_percentages(deduction_breakeven):
    """
    Validate deduction percentages against min/max limits.
    This replicates the backend validate_deduction_percentages functionality.
    """
    try:
        if not deduction_breakeven or not isinstance(deduction_breakeven, list):
            return {"success": True, "message": "No deduction breakeven to validate"}
        
        errors = []
        
        for row in deduction_breakeven:
            if not row.get('account'):
                continue
            
            fund_class = row.get('fund_class_id')
            account = row.get('account')
            percentage = row.get('percentage', 0)
            
            # Get min/max percentage for this account
            min_max = get_min_max_percentage(fund_class, account)
            
            if min_max and min_max.get('min_percentage') is not None and min_max.get('max_percentage') is not None:
                min_percentage = min_max.get('min_percentage')
                max_percentage = min_max.get('max_percentage')
                
                if percentage < min_percentage or percentage > max_percentage:
                    errors.append(f"Row#{row.get('idx', 'N/A')}: Percentage for account '{account}' must be between {min_percentage}% and {max_percentage}%.")
        
        if errors:
            return {"success": False, "errors": errors}
        
        return {"success": True, "message": "All percentages are valid"}
        
    except Exception as e:
        frappe.log_error(f"Error in validate_deduction_percentages: {str(e)}", "Deduction Percentage Validation Error")
        return {"success": False, "message": f"Error validating percentages: {str(e)}"}

def get_min_max_percentage(fund_class, account):
    """Get min/max percentage for a fund class and account combination"""
    try:
        if not fund_class or not account:
            return None
        
        result = frappe.db.sql("""
            SELECT min_percent, max_percent
            FROM `tabDeduction Details`
            WHERE parent = %(fund_class)s AND account = %(account)s
            LIMIT 1
        """, {
            'fund_class': fund_class,
            'account': account
        }, as_dict=True)
        
        if result:
            return {
                'min_percentage': result[0].get('min_percent'),
                'max_percentage': result[0].get('max_percent')
            }
        
        return None
        
    except Exception:
        return None

@frappe.whitelist()
def get_deduction_details_comprehensive(fund_class_id, company):
    """
    Get comprehensive deduction details for a fund class.
    This is an enhanced version of the existing get_deduction_details function.
    """
    try:
        if not fund_class_id:
            return {"success": False, "message": "Fund class ID is required"}
        
        if not company:
            return {"success": False, "message": "Company is required"}
        
        # Get deduction details with additional information
        result = frappe.db.sql("""
            SELECT 
                dd.company, 
                dd.income_type,
                it.project,
                dd.account, 
                dd.percentage, 
                dd.min_percent, 
                dd.max_percent,
                a.account_name,
                a.account_type,
                it.income_type_name
            FROM 
                `tabDeduction Details` dd
            LEFT JOIN `tabIncome Type` it ON dd.income_type = it.name
            LEFT JOIN `tabAccount` a ON dd.account = a.name
            WHERE 
                dd.parenttype = "Fund Class"
                and dd.parent = %(fund_class_id)s
                and dd.company = %(company)s
                and ifnull(dd.account, "") != ""
            ORDER BY dd.idx
        """, {
            'fund_class_id': fund_class_id,
            'company': company
        }, as_dict=True)
        
        if result:
            return {"success": True, "data": result}
        else:
            return {"success": False, "message": "No deduction details found"}
            
    except Exception as e:
        frappe.log_error(f"Error in get_deduction_details_comprehensive: {str(e)}", "Comprehensive Deduction Details Error")
        return {"success": False, "message": f"Error fetching deduction details: {str(e)}"}

@frappe.whitelist()
def calculate_deduction_amounts(payment_details, deduction_breakeven):
    """
    Calculate deduction amounts for payment details and deduction breakeven rows.
    This is useful for real-time calculation in the frontend.
    """
    try:
        if not payment_details or not deduction_breakeven:
            return {"success": False, "message": "Payment details and deduction breakeven are required"}
        
        calculated_data = []
        
        for payment_row in payment_details:
            payment_random_id = payment_row.get('random_id')
            donation_amount = payment_row.get('donation_amount', 0)
            
            # Find matching deduction rows
            matching_deductions = [
                d for d in deduction_breakeven 
                if d.get('random_id') == payment_random_id
            ]
            
            total_deduction = 0
            deduction_details = []
            
            for deduction_row in matching_deductions:
                percentage = deduction_row.get('percentage', 0)
                amount = donation_amount * (percentage / 100)
                
                deduction_details.append({
                    'income_type': deduction_row.get('income_type'),
                    'account': deduction_row.get('account'),
                    'percentage': percentage,
                    'amount': amount
                })
                
                total_deduction += amount
            
            calculated_data.append({
                'random_id': payment_random_id,
                'donation_amount': donation_amount,
                'total_deduction': total_deduction,
                'net_amount': donation_amount - total_deduction,
                'deduction_details': deduction_details
            })
        
        return {"success": True, "data": calculated_data}
        
    except Exception as e:
        frappe.log_error(f"Error in calculate_deduction_amounts: {str(e)}", "Deduction Amount Calculation Error")
        return {"success": False, "message": f"Error calculating deduction amounts: {str(e)}"}
        
@frappe.whitelist()
def get_deduction_details_comprehensive(fund_class_id, company):
    """
    Get comprehensive deduction details for a fund class.
    This is an enhanced version of the existing get_deduction_details function.
    """
    try:
        if not fund_class_id:
            return {"success": False, "message": "Fund class ID is required"}
        
        if not company:
            return {"success": False, "message": "Company is required"}
        
        # Get deduction details with additional information
        result = frappe.db.sql("""
            SELECT 
                dd.company, 
                dd.income_type,
                it.project,
                dd.account, 
                dd.percentage, 
                dd.min_percent, 
                dd.max_percent,
                a.account_name,
                a.account_type,
                it.income_type_name
            FROM 
                `tabDeduction Details` dd
            LEFT JOIN `tabIncome Type` it ON dd.income_type = it.name
            LEFT JOIN `tabAccount` a ON dd.account = a.name
            WHERE 
                dd.parenttype = "Fund Class"
                and dd.parent = %(fund_class_id)s
                and dd.company = %(company)s
                and ifnull(dd.account, "") != ""
            ORDER BY dd.idx
        """, {
            'fund_class_id': fund_class_id,
            'company': company
        }, as_dict=True)
        
        if result:
            return {"success": True, "data": result}
        else:
            return {"success": False, "message": "No deduction details found"}
            
    except Exception as e:
        frappe.log_error(f"Error in get_deduction_details_comprehensive: {str(e)}", "Comprehensive Deduction Details Error")
        return {"success": False, "message": f"Error fetching deduction details: {str(e)}"}

@frappe.whitelist()
def calculate_deduction_amounts(payment_details, deduction_breakeven):
    """
    Calculate deduction amounts for payment details and deduction breakeven rows.
    This is useful for real-time calculation in the frontend.
    """
    try:
        if not payment_details or not deduction_breakeven:
            return {"success": False, "message": "Payment details and deduction breakeven are required"}
        
        calculated_data = []
        
        for payment_row in payment_details:
            payment_random_id = payment_row.get('random_id')
            donation_amount = payment_row.get('donation_amount', 0)
            
            # Find matching deduction rows
            matching_deductions = [
                d for d in deduction_breakeven 
                if d.get('random_id') == payment_random_id
            ]
            
            total_deduction = 0
            deduction_details = []
            
            for deduction_row in matching_deductions:
                percentage = deduction_row.get('percentage', 0)
                amount = donation_amount * (percentage / 100)
                
                deduction_details.append({
                    'income_type': deduction_row.get('income_type'),
                    'account': deduction_row.get('account'),
                    'percentage': percentage,
                    'amount': amount
                })
                
                total_deduction += amount
            
            calculated_data.append({
                'random_id': payment_random_id,
                'donation_amount': donation_amount,
                'total_deduction': total_deduction,
                'net_amount': donation_amount - total_deduction,
                'deduction_details': deduction_details
            })
        
        return {"success": True, "data": calculated_data}
        
    except Exception as e:
        frappe.log_error(f"Error in calculate_deduction_amounts: {str(e)}", "Deduction Amount Calculation Error")
        return {"success": False, "message": f"Error calculating deduction amounts: {str(e)}"}
